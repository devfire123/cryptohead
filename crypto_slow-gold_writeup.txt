LA CTF 2025/2026 (crypto) - slow-gold
====================================

Flag: lactf{1_h0p3_y0u_l1v3_th1s_0ne_t0_th3_fullest}

This is a full technical writeup for the challenge `crypto/slow-gold`.

The key idea: the challenge uses an EMP-ZK arithmetic proof. A subtle bug in the
library's multiplication-gate batch check reduces a multi-gate random linear
combination into "check only the last multiplication gate", and the verifier
can read out enough of the check transcript to recover the prover's wire values
as a function of the public challenge X. Those wire values are evaluations of a
degree-9 polynomial; interpolating and factoring it yields the secret inputs,
which can then be submitted to get the flag.


0. Reproduction / "Screenshots"
-------------------------------

All commands below were executed from:
  /home/kali/Desktop/ctf/lactf_cryptochallenges

Solver transcript is saved here:
  writeup_artifacts/slowgold_solver_transcript_2.txt

Run:

  python3 solve_slowgold.py

Observed output (verbatim):

  [X=0] a=1811319579736929840 b=1185230980869603820 v9=1185230980869603820
  [X=1] a=1347261408062289609 b=1185230980869603821 v9=1185230980869603820
  [X=2] a=1623470127944424535 b=1185230980869603822 v9=1185230980869603820
  [X=3] a=1251409870297431806 b=1185230980869603823 v9=1185230980869603820
  [X=4] a=524114117384685984 b=1185230980869603824 v9=1185230980869603820
  [X=5] a=1334345023845748360 b=1185230980869603825 v9=1185230980869603820
  [X=6] a=122449731357871313 b=1185230980869603826 v9=1185230980869603820
  [X=7] a=2161881734017330867 b=1185230980869603827 v9=1185230980869603820
  [X=8] a=683443398518365972 b=1185230980869603828 v9=1185230980869603820
  [X=9] a=893322674715030543 b=1185230980869603829 v9=1185230980869603820
  [v9] 1185230980869603820
  [submit] start
  connected
  [submit] netio ready
  [submit] setup done
  [submit] zkp done
  [submit] guesses sent
  [submit] waiting flag...
  [submit] flag recv
  lactf{1_h0p3_y0u_l1v3_th1s_0ne_t0_th3_fullest}


1. What The Challenge Is Doing
------------------------------

The provided (patched) submission client is:
  dist/emp-zk/test/arith/slowgold_submit.cpp

The core computation is:

  - The prover (ALICE) has two secret arrays:
      array1[0..9], array2[0..9]  (field elements)
  - The verifier (BOB, us) chooses a public challenge X and sends it.
  - They compute:
      acc1(X) = Π_{i=0..9} (array1[i] + X)
      acc2(X) = Π_{i=0..9} (array2[i] + X)
    and enforce acc1(X) == acc2(X) in zero-knowledge.

In code, the "only" asserted relation is:

  dist/emp-zk/test/arith/slowgold_submit.cpp
    acc1 = acc1 * (array1[i] + X);
    acc2 = acc2 * (array2[i] + X);
    final_zero = acc1 - acc2;
    batch_reveal_check_zero(final_zero);

After the ZK proof completes, the server asks us to send 10 guesses (uint64),
and if the guesses match the hidden values, it sends the flag.

Interpretation (math):

Let f1(t) = Π (array1[i] + t) and f2(t) = Π (array2[i] + t).
They are degree-10 polynomials over a prime field. If f1(X) == f2(X) for a
random X in a large field, then (with overwhelming probability) f1 == f2 as
polynomials, hence the multisets {array1[i]} and {array2[i]} are equal.

So there is one hidden multiset of 10 values; either array is that multiset.


2. Field And EMP-ZK Representation
---------------------------------

The arithmetic field used here is:

  PR = 2305843009213693951 = 2^61 - 1

This is a Mersenne prime, used throughout EMP-ZK's arithmetic backend.

EMP-ZK stores authenticated values as "IT-MAC" style pairs:
  prover holds (value, mac_share)
  verifier holds "key" related to (value, mac_share) and the global delta.

You do NOT need the full EMP-ZK protocol to solve the challenge; you only need
one derived relation from the multiplication-gate batch check (next section).


3. The Multiplication Check Bug (Root Cause)
--------------------------------------------

The probe binary is:
  dist/emp-zk/bin/test_arith_slowgold_probe

Source:
  dist/emp-zk/test/arith/slowgold_probe.cpp

It runs the same ZK circuit, but afterwards prints a JSON object that contains:

  X, delta, seed, U, V, ka, kb, kc

Those values are captured from a header-only scratchpad:
  dist/emp-zk/emp-zk/emp-zk-arith/ostriple.h

Specifically, on the verifier side (BOB) the library stores:
  - delta (global MAC key, field element)
  - seed (random coefficient used by the multiplication check)
  - U, V (the prover's reported check sums)
  - ka, kb, kc (verifier-side key material for the *last* multiplication gate)

Now the bug:

In the arithmetic triple/check implementation, the multiplication-gate batch
check is supposed to combine ALL multiplication gates via a random linear
combination with coefficients chi[k] = seed^(k+1) (or similar).

In this challenge build, however, the loop inside
  FpOSTriple::andgate_correctness_check(...)
is:

  dist/emp-zk/emp-zk/emp-zk-arith/ostriple.h:351
    for (uint32_t i = start + task_n - 1, k = 0;
         i < start + task_n;
         ++i, ++k) {
      ...
      U += A0 * chi[k];
      V += A1 * chi[k];
    }

Because `i` is an unsigned 32-bit integer, this loop executes EXACTLY ONCE:
  - It starts at i = start + task_n - 1 (the last gate)
  - Condition is i < start + task_n, which is true for that single i
  - It increments i to start + task_n, and then the condition becomes false

Therefore, instead of summing over all multiplication gates, it only checks
the very last multiplication gate, with coefficient chi[0].

Also, chi is generated as:

  dist/emp-zk/emp-zk/emp-vole/utility.h:188
    coeff[0] = seed;
    coeff[i] = coeff[i-1] * seed;

And in `ostriple.h`, this arithmetic check uses only sz=1:

  dist/emp-zk/emp-zk/emp-zk-arith/ostriple.h:346
    uni_hash_coeff_gen(chi, seed, 1);

So chi[0] = seed.

Conclusion:

  U = A0 * seed
  V = A1 * seed

where A0, A1 are functions of the last multiplication gate's internal wires.

That means we can compute:

  A1 = V / seed  (mod PR), as long as seed != 0

This is the leak. `slowgold_probe.cpp` gives us `V` and `seed`, so we can
recover A1 for each probe run.


4. What Is A1 And Why It Gives A Linear System
----------------------------------------------

For a multiplication gate with left input "a", right input "b", and output
"p = a*b", the check code computes (prover side):

  dist/emp-zk/emp-zk/emp-zk-arith/ostriple.h:352-361
    a  = HIGH64(left[i]);
    ma = LOW64(left[i]);
    b  = HIGH64(right[i]);
    mb = LOW64(right[i]);
    mc = LOW64(gateout[i]);

    A0 = ma * mb
    A1 = a*mb + b*ma - mc

On the verifier side, it uses:

  dist/emp-zk/emp-zk/emp-zk-arith/ostriple.h:371-375
    ka = LOW64(left[i]);
    kb = LOW64(right[i]);
    kc = LOW64(gateout[i]);
    B  = ka*kb + kc*delta

And finally enforces for the batch check:

  A0 == delta*A1 + B

(With the bug, this is enforced only for the last multiplication gate.)

Now the crucial IT-MAC identities for verifier keys (derived from how EMP-ZK
builds them; see `authenticated_val_input()` and `auth_compute_mul_recv()`):

  ka = ma - delta*a
  kb = mb - delta*b
  kc = mc - delta*p

Rearrange:
  ma = ka + delta*a
  mb = kb + delta*b
  mc = kc + delta*p

Plug those into A1:

  A1 = a*(kb + delta*b) + b*(ka + delta*a) - (kc + delta*p)
     = a*kb + b*ka + 2*delta*a*b - kc - delta*p

Since p = a*b, we simplify:

  A1 = a*kb + b*ka + delta*p - kc

Rearrange to the exact linear relation used by the solver:

  kb*a + ka*b + delta*p = A1 + kc        (mod PR)

Everything on the right is observable per probe transcript:
  - ka, kb, kc, delta, seed, V are printed by the probe
  - A1 = V / seed (mod PR) due to the bug

Unknowns for that specific run:
  - a (left wire value of the last multiplication gate)
  - b (right wire value of the last multiplication gate)
  - p = a*b

But note: delta is fixed per connection, while ka/kb/kc (and thus the equation)
change per connection because the protocol uses fresh VOLE samples.


5. Solving For (a, b) Using 3 Probe Transcripts
------------------------------------------------

Each probe run gives a single linear equation in the three unknowns:

  kb*a + ka*b + delta*p = A1 + kc

If we collect 3 transcripts for the same public X, we can solve the 3x3 system
for (a, b, p) in the field PR, using modular Gaussian elimination.

The solver does exactly this:
  solve_slowgold.py: solve_linear_system_3(...)

It also sanity-checks that the recovered p matches a*b:
  (a*b) % PR == p

This prevents accidental use of a singular/degenerate triple of equations.


6. Why V9 Falls Out Immediately (b - X)
---------------------------------------

Now we interpret which gate is "the last multiplication gate" in the circuit.

The circuit multiplies in a loop:

  for i in 0..9:
    acc1 *= (array1[i] + X)
    acc2 *= (array2[i] + X)

Within each iteration, acc2's multiplication occurs after acc1's multiplication.
So the very last multiplication gate executed in the entire circuit is:

  acc2 = acc2 * (array2[9] + X)

Thus, for the last multiplication gate:
  a = acc2_before = Π_{i=0..8} (array2[i] + X)
  b = array2[9] + X

Therefore:
  array2[9] = b - X  (mod PR)

The solver records v9_votes = (b - X) across X=0..9 and takes the majority vote.
In practice it is constant and the vote just makes it robust to rare bad probes.


7. Recovering The Other 9 Values via Polynomial Interpolation + Factoring
-------------------------------------------------------------------------

From the previous section:

  a(X) = Π_{i=0..8} (array2[i] + X)

This is a degree-9 polynomial in X over the field PR.

If we can evaluate a(X) at 10 distinct X values, we can uniquely interpolate
the polynomial coefficients.

The solver chooses X = 0..9 and recovers a(X) using the linear-system method
above, producing points:

  (0, a0), (1, a1), ..., (9, a9)

Then it performs Lagrange interpolation in the field to obtain coefficients:

  P(X) = c0 + c1*X + ... + c9*X^9

Implementation:
  solve_slowgold.py: lagrange_interpolate(...)

Now, factor P(X) mod PR. Since:

  a(X) = Π_{i=0..8} (X + array2[i])

the roots of P(X) are:

  X = -array2[i]

So factoring P(X) into linear factors yields all 9 roots, hence all 9 values.

Implementation:
  solve_slowgold.py: roots_from_poly(...)
  (uses sympy Poly(..., modulus=PR) and factor_list())

Finally:
  recovered_values = { array2[0..8], array2[9] }


8. Submitting And Getting The Flag
----------------------------------

The submission client:
  dist/emp-zk/bin/test_arith_slowgold_submit

Accepts guesses via env var:
  SLOWGOLD_GUESSES=v0,v1,...,v9

The solver runs it after computing the values. The server replies with the flag:

  lactf{1_h0p3_y0u_l1v3_th1s_0ne_t0_th3_fullest}


9. Why This Works (Proof Sketch)
--------------------------------

There are two probabilistic arguments and two deterministic ones:

(A) Deterministic: bug => single-gate check
    The `for` loop in `ostriple.h` executes exactly once, so U and V are computed
    from only the last gate, with coefficient seed. Therefore A1 = V/seed.

(B) Deterministic: A1 + verifier keys => linear equation
    Using the IT-MAC relation between prover MAC shares (ma,mb,mc), values (a,b),
    product p=a*b, and verifier keys (ka,kb,kc) with delta, we derive:
      kb*a + ka*b + delta*p = A1 + kc

(C) Deterministic: last gate structure => polynomial evaluations
    The last gate is acc2_before * (array2[9]+X), so b-X reveals array2[9], and
    a(X) equals the degree-9 product Π_{i=0..8} (array2[i]+X).

(D) Probabilistic but overwhelming: interpolation + factoring recovers roots
    Given 10 distinct X values in a prime field, a degree-9 polynomial is uniquely
    determined by its evaluations, so interpolation recovers the exact polynomial.
    Factoring over a prime field yields its linear roots (the -array2[i]) since it
    is exactly a product of distinct linear factors in the intended construction.


10. Notes / Reliability
-----------------------

1) seed == 0:
   If a probe transcript has seed=0, then A1 = V/seed is undefined. The solver
   discards such rows and retries.

2) Singular 3x3 systems:
   Some triples of equations can be singular mod PR. The solver tries multiple
   combinations of collected rows until Gaussian elimination succeeds and the
   p == a*b consistency check passes.

3) Network flakiness:
   The probe wraps the binary with a timeout and retries; this is why the solve
   can take several minutes end-to-end.


Appendix: Relevant Files
------------------------

  - solve_slowgold.py
      Full exploit + interpolation + factoring + submission.

  - dist/emp-zk/test/arith/slowgold_submit.cpp
      The original protocol: prove Π(array1[i]+X) == Π(array2[i]+X).

  - dist/emp-zk/test/arith/slowgold_probe.cpp
      A helper client that prints the check transcript JSON used by the solver.

  - dist/emp-zk/emp-zk/emp-zk-arith/ostriple.h
      Where the bugged loop lives and where last-gate values are stored.

