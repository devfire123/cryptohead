<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>slow-gold (Crypto) | Axiom Vale</title>
    <meta
      name="description"
      content="LA CTF slow-gold: breaking EMP-ZK via a multiplication-gate batch-check bug; interpolate + factor to recover the hidden multiset."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Red+Hat+Display:wght@400;500;600;700&family=IBM+Plex+Mono:wght@300;400;500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="page">
      <header class="site-header">
        <div class="logo">Axiom Vale</div>
        <nav class="nav-links">
          <a href="index.html">Home</a>
          <a href="writeups.html">Writeups</a>
          <a href="blog.html">Blog</a>
          <a href="experience.html">Experience</a>
          <a href="projects.html">Projects</a>
          <a href="contact.html">Contact</a>
        </nav>
        <div class="badge">Crypto + Misc CTF</div>
      </header>

      <main>
        <section class="writeup-hero">
          <div>
            <p class="eyebrow">LA CTF / Crypto</p>
            <h1>slow-gold</h1>
            <p class="lede">
              EMP-ZK arithmetic proof; batch check collapses to the last mul gate; transcript leak;
              interpolate + factor to recover the hidden multiset.
            </p>
          </div>
          <div class="writeup-meta">
            <span class="tag">team: Flagsomnia</span>
            <span class="tag">handle: silent</span>
            <span class="tag">crypto</span>
            <span class="tag">zkp</span>
            <span class="tag">emp-zk</span>
          </div>
        </section>

        <section class="prose-card">
          <div class="prose">
            <figure class="figure">
              <img
                src="assets/slow-gold-solved.png"
                alt="Proof of solve for LA CTF crypto/slow-gold"
                loading="lazy"
              />
              <figcaption>Solve proof screenshot.</figcaption>
            </figure>

            <h3>Downloads</h3>
            <div class="downloads">
<a class="dl" href="artifacts/slow-gold/solve_slowgold.py" download><span class="dl-name">solve_slowgold.py</span><span class="dl-meta">6.8 KB</span></a>
<a class="dl" href="artifacts/slow-gold/slowgold_probe.cpp" download><span class="dl-name">slowgold_probe.cpp</span><span class="dl-meta">2.2 KB</span></a>
<a class="dl" href="artifacts/slow-gold/slowgold_submit.cpp" download><span class="dl-name">slowgold_submit.cpp</span><span class="dl-meta">2.5 KB</span></a>
<a class="dl" href="artifacts/slow-gold/ostriple.h" download><span class="dl-name">ostriple.h</span><span class="dl-meta">9.7 KB</span></a>
<a class="dl" href="crypto_slow-gold_writeup.txt" download><span class="dl-name">crypto_slow-gold_writeup.txt</span><span class="dl-meta">full notes</span></a>
            </div>

                        <h3>Writeup</h3>
            <div class="layout">
              <aside class="toc">
                <p class="toc-title">Contents</p>
                <a href="#tl-dr">TL;DR</a>
                <a href="#protocol">What The Protocol Proves</a>
                <a href="#bug">Root Cause</a>
                <a href="#leak">Turning The Leak Into Equations</a>
                <a href="#poly">Interpolation + Factoring</a>
                <a href="#submit">Submission</a>
                <a href="#notes">Reliability Notes</a>
              </aside>
              <article class="article">
                <section id="tl-dr" class="block">
                  <h4>TL;DR</h4>
                  <p>
                    The verifier transcript leaks the last multiplication gate because the EMP-ZK
                    batch check unintentionally checks only one gate. That leak gives a linear
                    equation in <code>(a, b, p=a*b)</code>. Solve three transcripts per X, recover
                    <code>a(X)</code> and <code>b(X)</code>, then: <code>v9 = b(X) - X</code>. The remaining 9 values
                    fall out by interpolating <code>a(X)</code> as a degree-9 polynomial and factoring it.
                  </p>
                  <div class="callout">
                    <p class="callout-title">Flag</p>
                    <pre><code class="language-text">lactf{1_h0p3_y0u_l1v3_th1s_0ne_t0_th3_fullest}</code></pre>
                  </div>
                </section>

                <section id="protocol" class="block">
                  <h4>What The Protocol Proves</h4>
                  <p>
                    The prover has two secret arrays of 10 field elements each. The verifier chooses
                    a public challenge <code>X</code>. The circuit computes:
                  </p>
                  <pre><code class="language-text">acc1(X) = prod_{i=0..9} (array1[i] + X)
acc2(X) = prod_{i=0..9} (array2[i] + X)</code></pre>
                  <p>
                    and enforces <code>acc1(X) == acc2(X)</code> inside EMP-ZK. If this holds for a random
                    X in a large prime field, the intended conclusion is that the two multisets of
                    10 values are equal.
                  </p>
                  <div class="callout subtle">
                    <p class="callout-title">Field</p>
                    <pre><code class="language-text">PR = 2305843009213693951  (2^61 - 1)</code></pre>
                  </div>
                </section>

                <section id="bug" class="block">
                  <h4>Root Cause</h4>
                  <p>
                    The multiplication-gate correctness check is supposed to combine all gates with
                    random coefficients. In this build, the loop that should iterate across gates
                    starts at the last gate and (because the index is unsigned) executes exactly once.
                    Net result:
                  </p>
                  <pre><code class="language-text">U = A0 * seed
V = A1 * seed</code></pre>
                  <p>
                    So for <code>seed != 0</code> we recover <code>A1 = V / seed (mod PR)</code> from a single probe.
                    The probe prints <code>seed</code> and <code>V</code>, which is the leak.
                  </p>
                </section>

                <section id="leak" class="block">
                  <h4>Turning The Leak Into Equations</h4>
                  <p>
                    For the last multiplication gate, let inputs be <code>a</code>, <code>b</code>, output <code>p=a*b</code>.
                    With EMP-ZK's authenticated representation, the transcript exposes verifier-side
                    key material <code>ka, kb, kc</code> and the global MAC delta <code>delta</code>. You can derive:
                  </p>
                  <pre><code class="language-text">kb*a + ka*b + delta*p = A1 + kc   (mod PR)</code></pre>
                  <p>
                    For a fixed public X, collect 3 transcripts and solve the 3x3 system for
                    <code>(a, b, p)</code>. Sanity check with <code>p == a*b</code>.
                  </p>
                  <div class="callout subtle">
                    <p class="callout-title">Last Gate Interpretation</p>
                    <p>
                      The circuit's last multiplication is <code>acc2 = acc2 * (array2[9] + X)</code>, so
                      <code>b(X) = array2[9] + X</code> and <code>v9 = b(X) - X</code>.
                    </p>
                  </div>
                </section>

                <section id="poly" class="block">
                  <h4>Interpolation + Factoring</h4>
                  <p>
                    The other recovered value is:
                  </p>
                  <pre><code class="language-text">a(X) = prod_{i=0..8} (array2[i] + X)</code></pre>
                  <p>
                    This is a degree-9 polynomial. Evaluate it at X = 0..9 (10 points), interpolate
                    the polynomial, then factor it mod PR. Its roots are <code>X = -array2[i]</code>, so you
                    recover the remaining 9 values.
                  </p>
                </section>

                <section id="submit" class="block">
                  <h4>Submission</h4>
                  <p>
                    Submit the 10 recovered values (any order) via:
                  </p>
                  <pre><code class="language-text">SLOWGOLD_GUESSES=v0,v1,...,v9</code></pre>
                </section>

                <section id="notes" class="block">
                  <h4>Reliability Notes</h4>
                  <ul>
                    <li><strong>seed == 0:</strong> skip that transcript (division undefined) and retry.</li>
                    <li><strong>singular systems:</strong> try different triples until elimination succeeds.</li>
                    <li><strong>integrity check:</strong> enforce <code>p == a*b</code> to avoid bad solves.</li>
                  </ul>
                  <p>
                    Full technical notes are available in
                    <a class="inline" href="crypto_slow-gold_writeup.txt">crypto_slow-gold_writeup.txt</a>.
                  </p>
                </section>
              </article>
            </div>
<h3>Reference Code</h3>
            <p>
              These are the exact files referenced in the writeup, included here for convenience.
            </p>

<details class="code">
  <summary>solve_slowgold.py</summary>
  <pre><code class="language-python">#!/usr/bin/env python3
import itertools
import json
import os
import subprocess
import sys
from collections import Counter

from sympy import Poly, symbols

PR = 2305843009213693951  # 2^61 - 1


def mod(x: int) -&gt; int:
    return x % PR


def inv(x: int) -&gt; int:
    x %= PR
    if x == 0:
        raise ZeroDivisionError(&quot;inv(0)&quot;)
    return pow(x, PR - 2, PR)


def run_probe(x: int) -&gt; dict:
    env = os.environ.copy()
    env[&quot;SLOWGOLD_X&quot;] = str(x)
    # Probe prints &quot;connected&quot; then one JSON line. Network/service can be flaky,
    # so retry a few times and extract the last JSON-looking line.
    for _ in range(6):
        try:
            out = subprocess.check_output(
                [&quot;bash&quot;, &quot;-lc&quot;, &quot;timeout 420s dist/emp-zk/bin/test_arith_slowgold_probe&quot;],
                env=env,
                text=True,
                stderr=subprocess.STDOUT,
            )
        except subprocess.CalledProcessError as e:
            out = e.output or &quot;&quot;
        lines = [ln.strip() for ln in out.splitlines() if ln.strip().startswith(&quot;{&quot;)]
        if lines:
            return json.loads(lines[-1])
    raise RuntimeError(f&quot;probe failed for X={x}&quot;)


def a1_from_row(r: dict) -&gt; int:
    seed = r[&quot;seed&quot;] % PR
    if seed == 0:
        raise ZeroDivisionError(&quot;seed=0&quot;)
    # V = seed * A1 for the last multiplication gate (due to a bug in the check loop).
    return (r[&quot;V&quot;] % PR) * inv(seed) % PR


def solve_linear_system_3(rows: list[dict]) -&gt; tuple[int, int, int]:
    # kb*a + ka*b + delta*p = A1 + kc
    M = []
    rhs = []
    for r in rows:
        A1 = a1_from_row(r)
        M.append([r[&quot;kb&quot;] % PR, r[&quot;ka&quot;] % PR, r[&quot;delta&quot;] % PR])
        rhs.append((A1 + (r[&quot;kc&quot;] % PR)) % PR)

    # Gaussian elimination for 3x3.
    M = [row[:] for row in M]
    rhs = rhs[:]
    n = 3
    for col in range(n):
        piv = None
        for i in range(col, n):
            if M[i][col] % PR != 0:
                piv = i
                break
        if piv is None:
            raise ValueError(&quot;singular&quot;)
        if piv != col:
            M[col], M[piv] = M[piv], M[col]
            rhs[col], rhs[piv] = rhs[piv], rhs[col]
        invp = inv(M[col][col])
        for j in range(col, n):
            M[col][j] = (M[col][j] * invp) % PR
        rhs[col] = (rhs[col] * invp) % PR
        for i in range(n):
            if i == col:
                continue
            factor = M[i][col] % PR
            if factor == 0:
                continue
            for j in range(col, n):
                M[i][j] = (M[i][j] - factor * M[col][j]) % PR
            rhs[i] = (rhs[i] - factor * rhs[col]) % PR

    a, b, p = rhs
    if (a * b) % PR != p:
        raise ValueError(&quot;inconsistent: p != a*b&quot;)
    return a, b, p


def solve_a_b_for_X(x: int, max_tries: int = 8) -&gt; tuple[int, int]:
    rows = []
    for _ in range(max_tries):
        r = run_probe(x)
        # Drop degenerate seeds early.
        if (r[&quot;seed&quot;] % PR) == 0:
            continue
        rows.append(r)
        if len(rows) &lt; 3:
            continue
        # Try all 3-subsets until one inverts.
        for comb in itertools.combinations(rows, 3):
            try:
                a, b, _p = solve_linear_system_3(list(comb))
                return a, b
            except Exception:
                pass
    raise RuntimeError(f&quot;failed to solve for X={x} after {max_tries} probes&quot;)


def poly_add(a: list[int], b: list[int]) -&gt; list[int]:
    n = max(len(a), len(b))
    out = [0] * n
    for i in range(n):
        out[i] = ( (a[i] if i &lt; len(a) else 0) + (b[i] if i &lt; len(b) else 0) ) % PR
    # trim
    while len(out) &gt; 1 and out[-1] == 0:
        out.pop()
    return out


def poly_mul(a: list[int], b: list[int]) -&gt; list[int]:
    out = [0] * (len(a) + len(b) - 1)
    for i, ai in enumerate(a):
        if ai == 0:
            continue
        for j, bj in enumerate(b):
            out[i + j] = (out[i + j] + ai * bj) % PR
    while len(out) &gt; 1 and out[-1] == 0:
        out.pop()
    return out


def lagrange_interpolate(xs: list[int], ys: list[int]) -&gt; list[int]:
    # Returns coeffs c0..c_{n-1} for degree &lt;= n-1 polynomial with f(xs[i])=ys[i].
    n = len(xs)
    assert n == len(ys)
    coeffs = [0]
    for i in range(n):
        xi = xs[i] % PR
        yi = ys[i] % PR
        # basis numerator: prod_{j!=i} (x - xj)
        num = [1]  # poly = 1
        den = 1
        for j in range(n):
            if i == j:
                continue
            xj = xs[j] % PR
            num = poly_mul(num, [(-xj) % PR, 1])  # (x - xj)
            den = (den * ((xi - xj) % PR)) % PR
        scale = (yi * inv(den)) % PR
        term = [(c * scale) % PR for c in num]
        coeffs = poly_add(coeffs, term)
    # pad to n
    coeffs += [0] * (n - len(coeffs))
    return [c % PR for c in coeffs[:n]]


def roots_from_poly(coeffs: list[int]) -&gt; list[int]:
    x = symbols(&quot;x&quot;)
    expr = 0
    for i, c in enumerate(coeffs):
        expr = (expr + int(c) * (x ** i))
    P = Poly(expr, x, modulus=PR)
    lc = int(P.LC()) % PR
    if lc != 1:
        P = Poly(P * inv(lc), x, modulus=PR)

    factors = P.factor_list()[1]
    roots = []
    for f, e in factors:
        if f.degree() != 1:
            raise RuntimeError(f&quot;unexpected non-linear factor: deg={f.degree()}&quot;)
        a1, a0 = [int(c) % PR for c in f.all_coeffs()]  # a1*x + a0
        r = (-a0 * inv(a1)) % PR
        roots.extend([r] * e)
    if len(roots) != 9:
        raise RuntimeError(f&quot;expected 9 roots, got {len(roots)}&quot;)
    return roots


def submit(values: list[int]) -&gt; str:
    env = os.environ.copy()
    env[&quot;SLOWGOLD_GUESSES&quot;] = &quot;,&quot;.join(str(int(v)) for v in values)
    env[&quot;SLOWGOLD_X&quot;] = &quot;0&quot;
    out = subprocess.check_output(
        [&quot;bash&quot;, &quot;-lc&quot;, &quot;timeout 240s dist/emp-zk/bin/test_arith_slowgold_submit&quot;],
        env=env,
        text=True,
        stderr=subprocess.STDOUT,
    )
    return out


def main() -&gt; int:
    # 10 points to interpolate a degree-9 polynomial a(X) = prod_{j=0..8} (v_j + X).
    xs = list(range(10))
    ays = []
    v9_votes = []

    for x in xs:
        a, b = solve_a_b_for_X(x)
        ays.append(a)
        v9_votes.append((b - x) % PR)
        print(f&quot;[X={x}] a={a} b={b} v9={v9_votes[-1]}&quot;, file=sys.stderr, flush=True)

    v9 = Counter(v9_votes).most_common(1)[0][0]
    print(f&quot;[v9] {v9}&quot;, file=sys.stderr, flush=True)

    coeffs = lagrange_interpolate(xs, ays)  # c0..c9
    roots = roots_from_poly(coeffs)  # roots are X = -v_j
    v_list = [(-r) % PR for r in roots]
    if v9 in v_list:
        # Rare, but handle duplicates gracefully.
        pass
    v_list.append(v9)

    # Sanity: 10 values.
    if len(v_list) != 10:
        raise RuntimeError(&quot;expected 10 values&quot;)

    # Submit. Any order is fine (server checks permutation).
    out = submit(v_list)
    sys.stdout.write(out)
    if &quot;lactf{&quot; in out:
        return 0
    return 1


if __name__ == &quot;__main__&quot;:
    raise SystemExit(main())
</code></pre>
</details>

<details class="code">
  <summary>slowgold_probe.cpp</summary>
  <pre><code class="language-cpp">#include &quot;emp-tool/emp-tool.h&quot;
#include &quot;emp-zk/emp-zk.h&quot;

#include &lt;cinttypes&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace emp;
using namespace std;

static constexpr int threads = 1;

int main(int argc, char **argv) {
  (void)argc;
  (void)argv;

  int party = BOB;
  const char *host = getenv(&quot;SLOWGOLD_HOST&quot;);
  if (!host)
    // NetIO uses inet_addr() and does not resolve hostnames.
    host = &quot;34.169.138.235&quot;;
  int port = 31183;

  uint64_t X = 0;
  if (const char *xs = getenv(&quot;SLOWGOLD_X&quot;)) {
    X = strtoull(xs, nullptr, 0);
  } else {
    // Fallback: read from stdin like the original client.
    cin &gt;&gt; X;
  }

  BoolIO&lt;NetIO&gt; *ios[threads];
  for (int i = 0; i &lt; threads; ++i) {
    ios[i] = new BoolIO&lt;NetIO&gt;(new NetIO(party == ALICE ? nullptr : host, port),
                              party == ALICE);
  }

  setup_zk_arith&lt;BoolIO&lt;NetIO&gt;&gt;(ios, threads, party);

  vector&lt;IntFp&gt; array1, array2;
  for (int i = 0; i &lt; 10; i++) {
    array1.push_back(IntFp(0, ALICE));
    array2.push_back(IntFp(0, ALICE));
  }

  // Send X as a public challenge.
  ZKFpExec::zk_exec-&gt;send_data(&amp;X, sizeof(uint64_t));

  IntFp acc1 = IntFp(1, PUBLIC);
  IntFp acc2 = IntFp(1, PUBLIC);
  for (int i = 0; i &lt; 10; i++) {
    acc1 = acc1 * (array1[i] + X);
    acc2 = acc2 * (array2[i] + X);
  }
  IntFp final_zero = acc1 + acc2.negate();
  batch_reveal_check_zero(&amp;final_zero, 1);

  finalize_zk_arith&lt;BoolIO&lt;NetIO&gt;&gt;();

  // Emit the pieces we need for the offline solver.
  const uint64_t delta = slowgold_last_delta_u64();
  const uint64_t seed = slowgold_last_mulcheck_seed();
  const uint64_t U = slowgold_last_mulcheck_U();
  const uint64_t V = slowgold_last_mulcheck_V();
  const uint64_t ka = slowgold_last_mulcheck_ka();
  const uint64_t kb = slowgold_last_mulcheck_kb();
  const uint64_t kc = slowgold_last_mulcheck_kc();

  // One JSON line; stable to parse.
  cout &lt;&lt; &quot;{&quot;
       &lt;&lt; &quot;\&quot;X\&quot;:&quot; &lt;&lt; X &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;delta\&quot;:&quot; &lt;&lt; delta &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;seed\&quot;:&quot; &lt;&lt; seed &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;U\&quot;:&quot; &lt;&lt; U &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;V\&quot;:&quot; &lt;&lt; V &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;ka\&quot;:&quot; &lt;&lt; ka &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;kb\&quot;:&quot; &lt;&lt; kb &lt;&lt; &quot;,&quot;
       &lt;&lt; &quot;\&quot;kc\&quot;:&quot; &lt;&lt; kc &lt;&lt; &quot;}&quot;
       &lt;&lt; &quot;\n&quot;;

  for (int i = 0; i &lt; threads; ++i) {
    delete ios[i]-&gt;io;
    delete ios[i];
  }
  return 0;
}
</code></pre>
</details>

<details class="code">
  <summary>slowgold_submit.cpp</summary>
  <pre><code class="language-cpp">#include &quot;emp-tool/emp-tool.h&quot;
#include &quot;emp-zk/emp-zk.h&quot;

#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace emp;
using namespace std;

static constexpr int threads = 1;

static vector&lt;uint64_t&gt; parse_u64_csv(const string &amp;s) {
  vector&lt;uint64_t&gt; out;
  string item;
  stringstream ss(s);
  while (getline(ss, item, &#x27;,&#x27;)) {
    if (item.empty())
      continue;
    out.push_back(strtoull(item.c_str(), nullptr, 0));
  }
  return out;
}

int main(int argc, char **argv) {
  (void)argc;
  (void)argv;

  cerr &lt;&lt; &quot;[submit] start\n&quot; &lt;&lt; flush;

  const char *gs = getenv(&quot;SLOWGOLD_GUESSES&quot;);
  if (!gs) {
    cerr &lt;&lt; &quot;need SLOWGOLD_GUESSES=comma,separated,10,values\n&quot;;
    return 2;
  }
  vector&lt;uint64_t&gt; guesses = parse_u64_csv(gs);
  if (guesses.size() != 10) {
    cerr &lt;&lt; &quot;need exactly 10 guesses, got &quot; &lt;&lt; guesses.size() &lt;&lt; &quot;\n&quot;;
    return 2;
  }

  uint64_t X = 0;
  if (const char *xs = getenv(&quot;SLOWGOLD_X&quot;)) {
    X = strtoull(xs, nullptr, 0);
  }

  int party = BOB;
  const char *host = getenv(&quot;SLOWGOLD_HOST&quot;);
  if (!host)
    host = &quot;34.169.138.235&quot;;
  int port = 31183;

  BoolIO&lt;NetIO&gt; *ios[threads];
  for (int i = 0; i &lt; threads; ++i) {
    ios[i] = new BoolIO&lt;NetIO&gt;(new NetIO(party == ALICE ? nullptr : host, port),
                              party == ALICE);
  }
  cerr &lt;&lt; &quot;[submit] netio ready\n&quot; &lt;&lt; flush;

  setup_zk_arith&lt;BoolIO&lt;NetIO&gt;&gt;(ios, threads, party);
  cerr &lt;&lt; &quot;[submit] setup done\n&quot; &lt;&lt; flush;

  vector&lt;IntFp&gt; array1, array2;
  for (int i = 0; i &lt; 10; i++) {
    array1.push_back(IntFp(0, ALICE));
    array2.push_back(IntFp(0, ALICE));
  }

  ZKFpExec::zk_exec-&gt;send_data(&amp;X, sizeof(uint64_t));

  IntFp acc1 = IntFp(1, PUBLIC);
  IntFp acc2 = IntFp(1, PUBLIC);
  for (int i = 0; i &lt; 10; i++) {
    acc1 = acc1 * (array1[i] + X);
    acc2 = acc2 * (array2[i] + X);
  }
  IntFp final_zero = acc1 + acc2.negate();
  batch_reveal_check_zero(&amp;final_zero, 1);

  finalize_zk_arith&lt;BoolIO&lt;NetIO&gt;&gt;();
  cerr &lt;&lt; &quot;[submit] zkp done\n&quot; &lt;&lt; flush;

  for (int i = 0; i &lt; 10; i++) {
    uint64_t g = guesses[i];
    ios[0]-&gt;io-&gt;send_data(&amp;g, sizeof(uint64_t));
  }
  cerr &lt;&lt; &quot;[submit] guesses sent\n&quot; &lt;&lt; flush;

  // Flag is always exactly 46 bytes in the challenge.
  string flag;
  flag.resize(46);
  cerr &lt;&lt; &quot;[submit] waiting flag...\n&quot; &lt;&lt; flush;
  ios[0]-&gt;io-&gt;recv_data(&amp;flag[0], 46);
  cerr &lt;&lt; &quot;[submit] flag recv\n&quot; &lt;&lt; flush;
  cout &lt;&lt; flag;

  for (int i = 0; i &lt; threads; ++i) {
    delete ios[i]-&gt;io;
    delete ios[i];
  }
  return 0;
}
</code></pre>
</details>

<details class="code">
  <summary>ostriple.h</summary>
  <pre><code class="language-cpp">#ifndef OS_TRIPLE_H__
#define OS_TRIPLE_H__

#include &quot;emp-ot/emp-ot.h&quot;
#include &quot;emp-zk/emp-zk-bool/bool_io.h&quot;
#include &quot;emp-zk/emp-zk-bool/cheat_record.h&quot;
#include &quot;emp-zk/emp-zk-bool/triple_auth.h&quot;

template &lt;typename IO&gt; class OSTriple {
public:
  int party, threads;
  block delta;

  // managing buffers storing COTs
  int check_cnt = 0;
  block *andgate_out_buffer = nullptr;
  block *andgate_left_buffer = nullptr;
  block *andgate_right_buffer = nullptr;

  GaloisFieldPacking pack;
  int64_t CHECK_SZ = 1024 * 1024;

  block choice[2], choice2[2];
  block minusone, one;
  IO *io;
  IO **ios;
  PRG prg;
  FerretCOT&lt;IO&gt; *ferret = nullptr;
  TripleAuth&lt;IO&gt; *auth_helper;
  ThreadPool *pool = nullptr;
  void *ferret_state = nullptr;

  OSTriple(int party, int threads, IO **ios, void *state = nullptr) {
    this-&gt;party = party;
    this-&gt;threads = threads;
    this-&gt;ferret_state = state;
    // initiate Iterative COT with regular noise and security against malicious
    // adv
    if (ferret_state == nullptr)
      ferret = new FerretCOT&lt;IO&gt;(3 - party, threads, ios, true);
    else {
      ferret = new FerretCOT&lt;IO&gt;(3 - party, threads, ios, true, false);
      ferret-&gt;disassemble_state(ferret_state, 10400000);
    }
    this-&gt;delta = ferret-&gt;Delta;
    io = ios[0];
    this-&gt;ios = ios;
    pool = new ThreadPool(threads);

    andgate_out_buffer = new block[CHECK_SZ];
    andgate_left_buffer = new block[CHECK_SZ];
    andgate_right_buffer = new block[CHECK_SZ];

    block tmp;
    ferret-&gt;rcot(&amp;tmp, 1);

    choice[0] = choice2[0] = zero_block;
    choice[1] = this-&gt;delta;
    minusone = makeBlock(0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFELL);
    one = makeBlock(0x0L, 0x1L);
    choice2[1] = one;

    auth_helper = new TripleAuth&lt;IO&gt;(party, io);
    if (party == BOB)
      auth_helper-&gt;set_delta(this-&gt;delta);
  }

  ~OSTriple() {
    if (check_cnt != 0) {
      andgate_correctness_check_manage();
    }
    if (!auth_helper-&gt;finalize())
      CheatRecord::put(&quot;emp-zk-bool finalize&quot;);
    if (ferret_state != nullptr)
      ferret-&gt;assemble_state(ferret_state, 10400000);
    delete ferret;
    delete[] andgate_out_buffer;
    delete[] andgate_left_buffer;
    delete[] andgate_right_buffer;
    delete auth_helper;
    delete pool;
  }

  uint64_t communication() {
    uint64_t res = 0;
    for (int i = 0; i &lt; threads; ++i)
      res += ios[i]-&gt;counter;
    return res;
  }

  /* ---------------------inputs----------------------*/
  /*
   * authenticated bits for inputs of the prover
   */
  void authenticated_bits_input(block *auth, const bool *in, int len) {
    ferret-&gt;rcot(auth, len);

    if (party == ALICE) {
      for (int i = 0; i &lt; len; ++i) {
        bool buff = getLSB(auth[i]) ^ in[i];
        set_value_in_block(auth[i], in[i]);
        io-&gt;send_bit(buff);
      }
    } else {
      for (int i = 0; i &lt; len; ++i) {
        bool buff = io-&gt;recv_bit();
        auth[i] = auth[i] ^ choice[buff];
        set_zero_bit(auth[i]);
      }
    }
  }

  /*
   * authenticated bits for computing AND gates
   */
  block auth_compute_and(block a, block b) {
    block auth;
    if (check_cnt == CHECK_SZ) {
      andgate_correctness_check_manage();
      check_cnt = 0;
    }

    ferret-&gt;rcot(&amp;auth, 1);
    andgate_left_buffer[check_cnt] = a;
    andgate_right_buffer[check_cnt] = b;

    if (party == ALICE) {
      bool s = getLSB(a) and getLSB(b);
      bool d = s ^ getLSB(auth);
      set_value_in_block(auth, s);
      io-&gt;send_bit(d);
    } else {
      bool d = io-&gt;recv_bit();
      auth = auth ^ choice[d];
      set_zero_bit(auth);
    }
    andgate_out_buffer[check_cnt] = auth;
    check_cnt++;
    return auth;
  }

  /* ---------------------check----------------------*/

  void andgate_correctness_check_manage() {
    io-&gt;flush();
    block seed = io-&gt;get_hash_block();
    vector&lt;future&lt;void&gt;&gt; fut;

    int share_seed_n = threads;
    block *share_seed = new block[share_seed_n];
    PRG(&amp;seed).random_block(share_seed, share_seed_n);

    uint32_t task_base = check_cnt / threads;
    uint32_t leftover = task_base + (check_cnt % task_base);
    uint32_t start = 0;
    block *sum = new block[2 * threads];
    for (int i = 0; i &lt; threads - 1; ++i) {
      fut.push_back(
          pool-&gt;enqueue([this, sum, i, start, task_base, share_seed]() {
            andgate_correctness_check(sum, i, start, task_base, share_seed[i]);
          }));
      start += task_base;
    }
    andgate_correctness_check(sum, threads - 1, start, leftover,
                              share_seed[threads - 1]);

    for (auto &amp;f : fut)
      f.get();

    if (party == ALICE) {
      block ope_data[128];
      ferret-&gt;rcot(ope_data, 128);
      uint64_t ch_bits[2];
      for (int i = 0; i &lt; 2; ++i) {
        if (getLSB(ope_data[64 * i + 63]))
          ch_bits[i] = 1;
        else
          ch_bits[i] = 0;
        for (int j = 62; j &gt;= 0; --j) {
          ch_bits[i] &lt;&lt;= 1;
          if (getLSB(ope_data[64 * i + j]))
            ch_bits[i]++;
        }
      }
      block A_star[2];
      A_star[1] = makeBlock(ch_bits[1], ch_bits[0]);
      pack.packing(A_star, ope_data);
      for (int i = 0; i &lt; threads; ++i) {
        A_star[0] = A_star[0] ^ sum[2 * i];
        A_star[1] = A_star[1] ^ sum[2 * i + 1];
      }
      io-&gt;send_data(A_star, 2 * sizeof(block));
    } else {
      block ope_data[128];
      ferret-&gt;rcot(ope_data, 128);
      block B_star;
      pack.packing(&amp;B_star, ope_data);
      for (int i = 0; i &lt; threads; ++i)
        B_star = B_star ^ sum[i];
      block A_star[2];
      io-&gt;recv_data(A_star, 2 * sizeof(block));
      block W;
      gfmul(A_star[1], this-&gt;delta, &amp;W);
      W = W ^ A_star[0];
      if (cmpBlock(&amp;W, &amp;B_star, 1) != 1)
        CheatRecord::put(&quot;emp_zk_bool AND batch check&quot;);
    }
    io-&gt;flush();
    delete[] share_seed;
    delete[] sum;
  }

  void andgate_correctness_check(block *ret, int thr_i, uint32_t start,
                                 uint32_t task_n, block chi_seed) {
    if (task_n == 0)
      return;
    block *left = andgate_left_buffer;
    block *right = andgate_right_buffer;
    block *gateout = andgate_out_buffer;

    if (party == ALICE) {
      block ch_tmp[2];
      ch_tmp[0] = zero_block;
      for (uint32_t i = start; i &lt; start + task_n; ++i) {
        block A0, A1;
        gfmul(left[i], right[i], &amp;A0);
        ch_tmp[1] = right[i];
        A1 = ch_tmp[getLSB(left[i])];
        ch_tmp[1] = left[i];
        A1 = A1 ^ ch_tmp[getLSB(right[i])];
        A1 = A1 ^ gateout[i];
        left[i] = A0;
        right[i] = A1;
      }
    } else {
      for (uint32_t i = start; i &lt; start + task_n; ++i) {
        block B;
        gfmul(left[i], right[i], &amp;B);
        block tmp;
        gfmul(gateout[i], this-&gt;delta, &amp;tmp);
        B = B ^ tmp;
        left[i] = B;
      }
    }

    block *chi = new block[task_n];
    uni_hash_coeff_gen(chi, chi_seed, task_n);
    if (party == ALICE) {
      vector_inn_prdt_sum_red(ret + 2 * thr_i, chi, left + start, task_n);
      vector_inn_prdt_sum_red(ret + 2 * thr_i + 1, chi, right + start, task_n);
    } else
      vector_inn_prdt_sum_red(ret + thr_i, chi, left + start, task_n);

    delete[] chi;
  }

  /*
   * verify the output
   * open and check if the value equals 1
   */
  void verify_output(bool *b, const block *output, int length) {
    for (int i = 0; i &lt; length; ++i) {
      if (party == ALICE) {
        b[i] = getLSB(output[i]);
        io-&gt;send_bit(b[i]);
      } else {
        b[i] = io-&gt;recv_bit();
      }
    }
    if (party == ALICE) {
      auth_helper-&gt;prv_check(b, output, length);
    } else
      auth_helper-&gt;ver_check(b, output, length);
  }

  /* ---------------------helper functions----------------------*/
  void set_zero_bit(block &amp;b) { b = b &amp; minusone; }

  void set_value_in_block(block &amp;b, bool v) {
    b = b &amp; minusone;
    b = b ^ choice2[v];
  }

  void sync() {
    io-&gt;flush();
    for (int i = 0; i &lt; threads; ++i) {
      ios[i]-&gt;flush();
    }
  }

  /* ---------------------debug functions----------------------*/

  void check_auth_mac(block *auth, bool *in, int len, IO *tio) {
    if (party == ALICE) {
      tio-&gt;send_data(auth, len * sizeof(block));
      tio-&gt;send_data(in, len * sizeof(bool));
    } else {
      block *auth_recv = new block[len];
      tio-&gt;recv_data(auth_recv, len * sizeof(block));
      tio-&gt;recv_data(in, len * sizeof(bool));
      for (int i = 0; i &lt; len; ++i) {
        if (in[i] != getLSB(auth_recv[i]))
          error(&quot;check1&quot;);
        set_zero_bit(auth[i]);
        block mac = auth[i] ^ choice[in[i]];
        if (!cmpBlock(&amp;mac, &amp;auth_recv[i], 1))
          error(&quot;check2&quot;);
      }
      delete[] auth_recv;
    }
  }
  void check_compute_and(block *a, block *b, block *c, int len, IO *tio) {
    if (party == ALICE) {
      tio-&gt;send_data(a, len * sizeof(block));
      tio-&gt;send_data(b, len * sizeof(block));
      tio-&gt;send_data(c, len * sizeof(block));
    } else {
      block *recv = new block[3 * len];
      tio-&gt;recv_data(recv, len * sizeof(block));
      tio-&gt;recv_data(recv + len, len * sizeof(block));
      tio-&gt;recv_data(recv + 2 * len, len * sizeof(block));
      for (int i = 0; i &lt; len; ++i) {
        bool ar = getLSB(recv[i]);
        bool br = getLSB(recv[len + i]);
        bool cr = getLSB(recv[2 * len + i]);
        if (cr != (ar &amp; br))
          error(&quot;check3&quot;);
        block v[3];
        v[0] = a[i];
        v[1] = b[i];
        v[2] = c[i];
        set_zero_bit(v[0]);
        set_zero_bit(v[1]);
        set_zero_bit(v[2]);
        v[0] = v[0] ^ choice[ar];
        v[1] = v[1] ^ choice[br];
        v[2] = v[2] ^ choice[cr];
        if (!cmpBlock(v, recv + i, 1))
          error(&quot;check4&quot;);
        if (!cmpBlock(v + 1, recv + len + i, 1))
          error(&quot;check5&quot;);
        if (!cmpBlock(v + 2, recv + 2 * len + i, 1))
          error(&quot;check6&quot;);
      }
      delete[] recv;
    }
  }
};
#endif
</code></pre>
</details>
          </div>
        </section>

        <section class="writeup-nav">
          <a class="secondary" href="writeups.html">&larr; Back to writeups</a>
        </section>
      </main>

      <footer class="footer">
        <p>(c) <span id="year"></span> Axiom Vale. Built for GitHub Pages.</p>
      </footer>
    </div>
    <script>
      const year = document.getElementById("year");
      if (year) year.textContent = new Date().getFullYear();
    </script>
  </body>
</html>
